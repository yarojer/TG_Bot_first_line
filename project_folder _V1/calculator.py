import pandas as pd
import logging



# Настройка логирования
logging.basicConfig(
    level=logging.INFO,  # Уровень логирования
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(),  # Логирование в консоль
        logging.FileHandler('logfile.log')  # Логирование в файл
    ]
)
logger = logging.getLogger(__name__)

def filter_and_sum_transactions(df, start_date, end_date, document_type=None, payment_reason=None, brand_name=None):
    logger.info(f"Столбцы в DataFrame: {df.columns.tolist()}")
    
    # Проверка наличия нужного столбца перед обработкой
    if 'Дата заказа покупателем' not in df.columns:
        raise KeyError("Отсутствует столбец 'Дата заказа покупателем' в DataFrame")
    
    df['Дата заказа покупателем'] = pd.to_datetime(df['Дата заказа покупателем'], errors='coerce')
    
    # Фильтрация по дате
    df_filtered = df[(df['Дата заказа покупателем'] >= start_date) & (df['Дата заказа покупателем'] <= end_date)]
    
    logger.info(f"Строк до фильтрации по документу и обоснованию: {df_filtered.shape[0]}")
    logger.info(f"Уникальные значения в 'Тип документа': {df_filtered['Тип документа'].unique()}")
    logger.info(f"Уникальные значения в 'Обоснование для оплаты': {df_filtered['Обоснование для оплаты'].unique()}")
    logger.info(f"df_filtered после фильтрации по дате: {df_filtered.head()}")

    # Фильтрация по "Тип документа"
    if document_type is not None:
        if 'Тип документа' in df_filtered.columns:
            if pd.isna(document_type):
                df_filtered = df_filtered[pd.isna(df_filtered['Тип документа'])]
            else:
                df_filtered = df_filtered[df_filtered['Тип документа'] == document_type]
        else:
            raise KeyError("Отсутствует столбец 'Тип документа'")
    
    # Фильтрация по "Обоснование для оплаты"
    if payment_reason:
        if 'Обоснование для оплаты' in df_filtered.columns:
            df_filtered = df_filtered[df_filtered['Обоснование для оплаты'] == payment_reason]
        else:
            raise KeyError("Отсутствует столбец 'Обоснование для оплаты'")
    
    logger.info(f"Строк после фильтрации по документу '{document_type}' и обоснованию '{payment_reason}': {df_filtered.shape[0]}")
    logger.info(f"df_filtered после фильтрации по документу и обоснованию: {df_filtered.head()}")

    # Фильтрация по "Бренд"
    if brand_name:
        if 'Бренд' in df_filtered.columns:
            df_filtered = df_filtered[df_filtered['Бренд'] == brand_name]
        else:
            raise KeyError("Отсутствует столбец 'Бренд'")
    
    logger.info(f"Строк после фильтрации по бренду '{brand_name}': {df_filtered.shape[0]}")
    logger.info(f"df_filtered после фильтрации по бренду: {df_filtered.head()}")

    # Подсчеты по нужным столбцам
    transaction_count = df_filtered.shape[0]
    total_amount_seller = df_filtered['К перечислению Продавцу за реализованный Товар'].sum() if 'К перечислению Продавцу за реализованный Товар' in df_filtered.columns else 0
    retail_price_discount = df_filtered['Цена розничная с учетом согласованной скидки'].sum() if 'Цена розничная с учетом согласованной скидки' in df_filtered.columns else 0
    delivery_services = df_filtered['Услуги по доставке товара покупателю'].sum() if 'Услуги по доставке товара покупателю' in df_filtered.columns else 0
    total_penalties = df_filtered['Общая сумма штрафов'].sum() if 'Общая сумма штрафов' in df_filtered.columns else 0

    # Логирование финального состояния df_filtered
    logger.info(f"Финальный df_filtered: {df_filtered.head()}")
    logger.info(f"Финальный размер df_filtered: {df_filtered.shape}")

    return {
        "Тип документа": document_type,
        "Обоснование для оплаты": payment_reason,
        "Количество транзакций": transaction_count,
        "К перечислению Продавцу за реализованный Товар": total_amount_seller,
        "Цена розничная с учетом согласованной скидки": retail_price_discount,
        "Услуги по доставке товара покупателю": delivery_services,
        "Общая сумма штрафов": total_penalties
    }

def calculate_all_combinations(df, start_date, end_date, analysis_type=None, article_id=None, brand_name=None):
    ##if not isinstance(df, pd.DataFrame):
        ##raise TypeError("Ожидался объект DataFrame, но был передан другой тип данных.")
    
    # Преобразование дат
    start_date = pd.to_datetime(start_date, errors='coerce', dayfirst=True)
    end_date = pd.to_datetime(end_date, errors='coerce', dayfirst=True)
    
    logger.info(f"После преобразования - Start Date: {start_date}, End Date: {end_date}")

    if analysis_type == 'Артикул' and article_id:
        df_filtered = df[df['Артикул'] == article_id]
        logger.info(f"Фильтрация по Артикулу {article_id}: {df_filtered.shape}")
    elif analysis_type == 'Бренд' and brand_name:
        df_filtered = df[df['Бренд'] == brand_name]
        logger.info(f"Фильтрация по Бренду {brand_name}: {df_filtered.shape}")
    else:
        df_filtered = df

    # Логирование состояния df_filtered
    logger.info(f"DataFrame после фильтрации - Размер: {df_filtered.shape}")
    logger.info(f"Столбцы DataFrame: {df_filtered.columns.tolist()}")

    # Проверка наличия нужных колонок
    required_columns = ['Тип документа', 'Обоснование для оплаты']
    if not all(col in df_filtered.columns for col in required_columns):
        missing_cols = [col for col in required_columns if col not in df_filtered.columns]
        logger.error(f"Отсутствуют необходимые столбцы в DataFrame: {missing_cols}")
        raise KeyError(f"Отсутствуют необходимые столбцы в DataFrame: {missing_cols}")
    
    unique_combinations = df_filtered[['Тип документа', 'Обоснование для оплаты']].drop_duplicates()
    logger.info(f"Найдено {len(unique_combinations)} уникальных комбинаций")
    
    results = []
    
    for _, row in unique_combinations.iterrows():
        document_type = row['Тип документа']
        payment_reason = row['Обоснование для оплаты']
        
        logger.info(f"Обработка комбинации: {document_type} с обоснованием: {payment_reason}")
        transaction_summary = filter_and_sum_transactions(df_filtered, start_date, end_date, document_type=document_type, payment_reason=payment_reason, brand_name=brand_name)
        
        results.append({
            'Тип документа': document_type,
            'Обоснование для оплаты': payment_reason,
            **transaction_summary
        })
    
    logger.info("Вычисления комбинаций завершены.")
    return pd.DataFrame(results)


def log_dataframe_info(df, name):
    """
    Логирование размера и первых строк DataFrame для диагностики.
    """
    logger.info(f"DataFrame '{name}' - Размер: {df.shape}")
    logger.info(f"Первые 5 строк '{name}':\n{df.head()}")

def generate_summary_data(df, start_date, end_date):
    """
    Генерация данных для записи в лист "Итоговые данные".
    """
    logger.info("Генерация итоговых данных для Excel.")

    # Расчет суммы транзакций Корректная продажа Корректный возврат Сторно возвратов Сторно продаж
    sale_transactions = df[(df['Тип документа'] == 'Продажа') & 
                            (df['Обоснование для оплаты'] == 'Продажа')]['Количество транзакций'].sum() + df[(df['Тип документа'] == 'Продажа') & 
                            (df['Обоснование для оплаты'] == 'Корректная продажа')]['Количество транзакций'].sum() + df[(df['Тип документа'] == 'Продажа') & 
                            (df['Обоснование для оплаты'] == 'Сторно возвратов')]['Количество транзакций'].sum()+df[(df['Тип документа'] == 'продажа') & 
                            (df['Обоснование для оплаты'] == 'Продажа')]['Количество транзакций'].sum() + df[(df['Тип документа'] == 'продажа') & 
                            (df['Обоснование для оплаты'] == 'Корректная продажа')]['Количество транзакций'].sum() + df[(df['Тип документа'] == 'продажа') & 
                            (df['Обоснование для оплаты'] == 'Сторно возвратов')]['Количество транзакций'].sum()
    return_transactions = df[(df['Тип документа'] == 'Возврат') & 
                            (df['Обоснование для оплаты'] == 'Возврат')]['Количество транзакций'].sum() + df[(df['Тип документа'] == 'Возврат') & 
                            (df['Обоснование для оплаты'] == 'Корректный возврат')]['Количество транзакций'].sum() + df[(df['Тип документа'] == 'Возврат') & 
                            (df['Обоснование для оплаты'] == 'Сторно продаж')]['Количество транзакций'].sum()+df[(df['Тип документа'] == 'возврат') & 
                            (df['Обоснование для оплаты'] == 'Возврат')]['Количество транзакций'].sum() + df[(df['Тип документа'] == 'возврат') & 
                            (df['Обоснование для оплаты'] == 'Корректный возврат')]['Количество транзакций'].sum() + df[(df['Тип документа'] == 'возврат') & 
                            (df['Обоснование для оплаты'] == 'Сторно продаж')]['Количество транзакций'].sum()
    total_transactions = sale_transactions - return_transactions

    # Расчет комиссии c компенсациями 
    sale_commission = df[(df['Тип документа'] == 'Продажа') & 
                            (df['Обоснование для оплаты'] == 'Продажа')]['Цена розничная с учетом согласованной скидки'].sum() - df[(df['Тип документа'] == 'Продажа') & 
                            (df['Обоснование для оплаты'] == 'Продажа')]['К перечислению Продавцу за реализованный Товар'].sum() - df[(df['Тип документа'] == 'Продажа') & 
                            (df['Обоснование для оплаты'] == 'Добровольная компенсация при возврате')]['К перечислению Продавцу за реализованный Товар'].sum() - df[(df['Тип документа'] == 'Продажа') & 
                            (df['Обоснование для оплаты'] == 'Компенсация ущерба')]['К перечислению Продавцу за реализованный Товар'].sum() + df[(df['Тип документа'] == 'продажа') & 
                            (df['Обоснование для оплаты'] == 'Продажа')]['Цена розничная с учетом согласованной скидки'].sum() - df[(df['Тип документа'] == 'продажа') & 
                            (df['Обоснование для оплаты'] == 'Продажа')]['К перечислению Продавцу за реализованный Товар'].sum() - df[(df['Тип документа'] == 'продажа') & 
                            (df['Обоснование для оплаты'] == 'Добровольная компенсация при возврате')]['К перечислению Продавцу за реализованный Товар'].sum() - df[(df['Тип документа'] == 'продажа') & 
                            (df['Обоснование для оплаты'] == 'Компенсация ущерба')]['К перечислению Продавцу за реализованный Товар'].sum()
    return_commission = df[(df['Тип документа'] == 'Возврат') & 
                            (df['Обоснование для оплаты'] == 'Возврат')]['Цена розничная с учетом согласованной скидки'].sum() - df[(df['Тип документа'] == 'Возврат') & 
                            (df['Обоснование для оплаты'] == 'Возврат')]['К перечислению Продавцу за реализованный Товар'].sum() - df[(df['Тип документа'] == 'Возврат') & 
                            (df['Обоснование для оплаты'] == 'Добровольная компенсация при возврате')]['К перечислению Продавцу за реализованный Товар'].sum() - df[(df['Тип документа'] == 'Возврат') & 
                            (df['Обоснование для оплаты'] == 'Компенсация ущерба')]['К перечислению Продавцу за реализованный Товар'].sum() + df[(df['Тип документа'] == 'возврат') & 
                            (df['Обоснование для оплаты'] == 'Возврат')]['Цена розничная с учетом согласованной скидки'].sum() - df[(df['Тип документа'] == 'возврат') & 
                            (df['Обоснование для оплаты'] == 'Возврат')]['К перечислению Продавцу за реализованный Товар'].sum() - df[(df['Тип документа'] == 'возврат') & 
                            (df['Обоснование для оплаты'] == 'Добровольная компенсация при возврате')]['К перечислению Продавцу за реализованный Товар'].sum() - df[(df['Тип документа'] == 'возврат') & 
                            (df['Обоснование для оплаты'] == 'Компенсация ущерба')]['К перечислению Продавцу за реализованный Товар'].sum()
    total_commission = sale_commission - return_commission

    # Расчет суммы итоговой суммы оплат с учетом скидок
    sale_velus = df[(df['Тип документа'] == 'Продажа') & 
                            (df['Обоснование для оплаты'] == 'Продажа')]['Цена розничная с учетом согласованной скидки'].sum() + df[(df['Тип документа'] == 'Продажа') & 
                            (df['Обоснование для оплаты'] == 'Корректная продажа')]['Цена розничная с учетом согласованной скидки'].sum() + df[(df['Тип документа'] == 'Продажа') & 
                            (df['Обоснование для оплаты'] == 'Сторно возвратов')]['Цена розничная с учетом согласованной скидки'].sum() + df[(df['Тип документа'] == 'продажа') & 
                            (df['Обоснование для оплаты'] == 'Продажа')]['Цена розничная с учетом согласованной скидки'].sum() + df[(df['Тип документа'] == 'продажа') & 
                            (df['Обоснование для оплаты'] == 'Корректная продажа')]['Цена розничная с учетом согласованной скидки'].sum() + df[(df['Тип документа'] == 'продажа') & 
                            (df['Обоснование для оплаты'] == 'Сторно возвратов')]['Цена розничная с учетом согласованной скидки'].sum()
    return_velus = df[(df['Тип документа'] == 'Возврат') & 
                            (df['Обоснование для оплаты'] == 'Возврат')]['Цена розничная с учетом согласованной скидки'].sum() + df[(df['Тип документа'] == 'Возврат') & 
                            (df['Обоснование для оплаты'] == 'Корректный возврат')]['Цена розничная с учетом согласованной скидки'].sum() + df[(df['Тип документа'] == 'Возврат') & 
                            (df['Обоснование для оплаты'] == 'Сторно продаж')]['Цена розничная с учетом согласованной скидки'].sum() + df[(df['Тип документа'] == 'возврат') & 
                            (df['Обоснование для оплаты'] == 'Возврат')]['Цена розничная с учетом согласованной скидки'].sum() + df[(df['Тип документа'] == 'возврат') & 
                            (df['Обоснование для оплаты'] == 'Корректный возврат')]['Цена розничная с учетом согласованной скидки'].sum() + df[(df['Тип документа'] == 'возврат') & 
                            (df['Обоснование для оплаты'] == 'Сторно продаж')]['Цена розничная с учетом согласованной скидки'].sum()
    total_velus = sale_velus - return_velus

    # Расчет удержаний с учетом условий
    voluntary_compensation_sale = df[(df['Тип документа'] == 'Продажа') & 
                            (df['Обоснование для оплаты'] == 'Добровольная компенсация при возврате')]['К перечислению Продавцу за реализованный Товар'].sum()+df[(df['Тип документа'] == 'продажа') & 
                            (df['Обоснование для оплаты'] == 'Добровольная компенсация при возврате')]['К перечислению Продавцу за реализованный Товар'].sum()
    voluntary_compensation_return = df[(df['Тип документа'] == 'Возврат') & 
                            (df['Обоснование для оплаты'] == 'Добровольная компенсация при возврате')]['К перечислению Продавцу за реализованный Товар'].sum()+df[(df['Тип документа'] == 'возврат') & 
                            (df['Обоснование для оплаты'] == 'Добровольная компенсация при возврате')]['К перечислению Продавцу за реализованный Товар'].sum()
    total_voluntary_compensation = voluntary_compensation_sale - voluntary_compensation_return

    # Расчет компенсации ущерба с учетом условий
    damage_compensation_sale = df[(df['Тип документа'] == 'Продажа') & 
                            (df['Обоснование для оплаты'] == 'Компенсация ущерба')]['К перечислению Продавцу за реализованный Товар'].sum()+df[(df['Тип документа'] == 'продажа') & 
                            (df['Обоснование для оплаты'] == 'Компенсация ущерба')]['К перечислению Продавцу за реализованный Товар'].sum()
    damage_compensation_return = df[(df['Тип документа'] == 'Возврат') & 
                            (df['Обоснование для оплаты'] == 'Компенсация ущерба')]['К перечислению Продавцу за реализованный Товар'].sum()+df[(df['Тип документа'] == 'возврат') & 
                            (df['Обоснование для оплаты'] == 'Компенсация ущерба')]['К перечислению Продавцу за реализованный Товар'].sum()
    total_damage_compensation = damage_compensation_sale - damage_compensation_return

    # Расчет старых компенсаций Авансовая оплата за товар без движения
    sale_NoMove =  df[(df['Тип документа'] == 'Продажа') & 
                            (df['Обоснование для оплаты'] == 'Авансовая оплата за товар без движения')]['К перечислению Продавцу за реализованный Товар'].sum()+df[(df['Тип документа'] == 'продажа') & 
                            (df['Обоснование для оплаты'] == 'Авансовая оплата за товар без движения')]['К перечислению Продавцу за реализованный Товар'].sum()
    return_NoMove = df[(df['Тип документа'] == 'Возврат') & 
                            (df['Обоснование для оплаты'] == 'Авансовая оплата за товар без движения')]['К перечислению Продавцу за реализованный Товар'].sum()+df[(df['Тип документа'] == 'возврат') & 
                            (df['Обоснование для оплаты'] == 'Авансовая оплата за товар без движения')]['К перечислению Продавцу за реализованный Товар'].sum()
    total_NoMove = sale_NoMove - return_NoMove
    
    # Расчет старых компенсаций Компенсация подмененного товара
    sale_Substitution =  df[(df['Тип документа'] == 'Продажа') & 
                            (df['Обоснование для оплаты'] == 'Компенсация подмененного товара')]['К перечислению Продавцу за реализованный Товар'].sum()+df[(df['Тип документа'] == 'продажа') & 
                            (df['Обоснование для оплаты'] == 'Компенсация подмененного товара')]['К перечислению Продавцу за реализованный Товар'].sum()
    return_Substitution = df[(df['Тип документа'] == 'Возврат') & 
                            (df['Обоснование для оплаты'] == 'Компенсация подмененного товара')]['К перечислению Продавцу за реализованный Товар'].sum()+df[(df['Тип документа'] == 'возврат') & 
                            (df['Обоснование для оплаты'] == 'Компенсация подмененного товара')]['К перечислению Продавцу за реализованный Товар'].sum()
    total_Substitution = sale_Substitution - return_Substitution

    #Расчет старых компенсаций Частичная компенсация брака
    sale_Marriage =  df[(df['Тип документа'] == 'Продажа') & 
                            (df['Обоснование для оплаты'] == 'Частичная компенсация брака')]['К перечислению Продавцу за реализованный Товар'].sum()+df[(df['Тип документа'] == 'продажа') & 
                            (df['Обоснование для оплаты'] == 'Частичная компенсация брака')]['К перечислению Продавцу за реализованный Товар'].sum()
    return_Marriage = df[(df['Тип документа'] == 'Возврат') & 
                            (df['Обоснование для оплаты'] == 'Частичная компенсация брака')]['К перечислению Продавцу за реализованный Товар'].sum()+df[(df['Тип документа'] == 'возврат') & 
                            (df['Обоснование для оплаты'] == 'Частичная компенсация брака')]['К перечислению Продавцу за реализованный Товар'].sum()
    total_Marriage = sale_Marriage - return_Marriage

    # Заполнение итоговых данных
    summary_data = {
        "A": [
            f"Данные за период {start_date.strftime('%d.%m.%Y')} - {end_date.strftime('%d.%m.%Y')}",  # Заголовок с периодом
            "Оплат",  # Оплат
            "Итоговая сумма оплат с учетом скидки",  # Итоговая сумма оплат с учетом скидки
            "Комиссия ВБ(С учетом компенсаций)",  # Комиссия ВБ
            "Процент комиссии",  # Процент комиссии
            "Со комиссионные расходы:",  # Со комиссионные расходы (заголовок)
            "Добровольная компенсация при возврате",  # Добровольная компенсация при возврате
            "Компенсация ущерба",  # Компенсация ущерба
            "Авансовая оплата за товар без движения",
            "Компенсация подмененного товара",
            "Частичная компенсация брака",
            "Логистика",  # Логистика
        ],
        "B": [
            None,  # Пустая ячейка для заголовка
            total_transactions,  # Оплат
            total_velus,  # Итоговая сумма оплат с учетом скидки
            total_commission,  #"Комиссия ВБ(С учетом компенсаций)"
            total_commission / total_velus * 100 if df['Цена розничная с учетом согласованной скидки'].sum() != 0 else 0,  # Процент комиссии
            None,  # Пустая ячейка для разделителя
            total_voluntary_compensation,  # Добровольная компенсация при возврате
            total_damage_compensation,  # Компенсация ущерба
            total_NoMove,
            total_Substitution,
            total_Marriage,
            df['Услуги по доставке товара покупателю'].sum(),  # Логистика
        ]
    }

    logger.info("Итоговые данные сгенерированы.")
    return pd.DataFrame(summary_data)

def save_to_excel(df, start_date, end_date, filename="итоговый_отчет.xlsx"):
    logger.info("Начало сохранения файла Excel.")
    
    try:
        summary_df = generate_summary_data(df, start_date, end_date)
        
        with pd.ExcelWriter(filename, engine='xlsxwriter') as writer:
            summary_df.to_excel(writer, sheet_name="Итоговые данные", index=False, header=False)
            logger.info("'Итоговые данные' записаны успешно.")
            
            df.to_excel(writer, sheet_name="Общие данные", index=False)
            logger.info("'Общие данные' записаны успешно.")
        
        logger.info(f"Файл {filename} успешно сохранен.")
        
    except Exception as e:
        logger.error(f"Ошибка при сохранении файла Excel: {e}")
        raise

